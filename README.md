# Shrimp.Protocol

基于`aiocqhttp`适配器的**无需公网ip**且**无需内网穿透**但**低效**的 *双工通信协议*。

## 原理

1. 启动插件后会在astrbot所在主机的**25565**端口开放一个`http`服务器，可以使用**SocketIO**直接连接。
2. 插件会监听所有bot实例所在会话中的消息，如果侦测到是来自`shrimp`协议头发送的url就会尝试解析为命令，**cook**命令即为控制插件从SocketIO服务端向所有客户端发送消息。
3. 客户端接收消息时则控制目标bot实例往自身所在的所有会话发送**cook**命令。

## 与双工通信的关系

从上文的逻辑链条不难看出，其他应用程序向本机25565端口发送数据时会被astrbot转发到QQ群，而其他安装了此插件且bot实例位于同一QQ群的账号就能收到消息并使用astrbot转发回25565端口。

> 至此，数据完全由QQ转发，整个网络传输流程都在本机内网！

## 用法

1. 在不同网络下的设备登入不同QQ账号和不同astrbot实例。
2. 安装相同版本的**本插件**。
3. 将两个QQ账号拉入同一个群聊。
4. 由第三个账号在群聊中发送`$shrimp://join`（手动触发命令让两个QQ主动作为协议对等体加入通信房间），等待两个账号都输出 **“煮豆燃豆萁，豆在釜中泣”** 。
5. 信道建立完成！在两个设备分别使用**SocketIO**连接本机25565端口。
6. 一方机器向服务端提交`data`事件并提交JSON数据

   ```json
   {
        "data": "hello world", //消息具体内容
        "peer": "bot实例的名字" //对等体
   }
   ```

   另一方机器会被服务端下发`data`事件，数据结构与提交时相同。

## ⚠️重要提示

### Peer还是Server-Client？

使用QQ群进行通信本身就是一个数据相当不安全的行为，因此本协议不存在传统的**服务端<--->客户端**的双工通信架构，也自然不存在鉴权。请不要尝试给这个协议添加所谓的安全防护，没有任何意义。

这个协议只存在**对等体**概念，所有加入网络的节点都是对等的，无人有超越权限，也无人没有权限。

### 不要宣发太过！不要高频、大量使用

这种使用QQ进行非正常通信的行为肯定会被腾讯严格封杀，如果因此原因导致QQ被封，则本插件不付任何责任。

## ⚠️⚠️更重要的提示

这只是个娱乐项目！不要较真！

显然我知道这个协议的弊端很多，比如速度极其慢，数据不安全，容易被封号，但如上文所说，这只是个娱乐协议，不要当真！
